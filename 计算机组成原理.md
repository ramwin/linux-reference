# 计算机组成原理

## 资料
* https://www2.imm.dtu.dk/~masca/chisel-book-chinese.pdf

## [ROB](https://www.youtube.com/watch?v=TnxJA6uyP7Y)
[HPCA](https://www.youtube.com/playlist?list=PLAwxTw4SYaPmqpjgrmf4-DGlaeV0om4iP)
Reorder Buffer
用一个表,包含[REG,VAL,DONE](https://www.youtube.com/watch?v=TnxJA6uyP7Y). 
问题后面如果有需要回退时怎么知道回退到哪个  
如果后面有要用到ROB里面的REG, 难道要每行都去查询一遍吗  
ROB不区分线程, 那线程切换时,CPU是不是要等待ROB全部done  

## 术语
* 存储单元
每个存储单元的地址是唯一的
位宽，一个存储单元保存了多少个字节  

* 地址总线
> CPU要想访问某个存储单元，必须要通过地址总线给出相应的 地址， 因此如果地址总线的宽度为N，则CPU能管理的存储单元数最多为2的N次方个
* MAR(Memory Address Register 存储地址寄存器)
CPU通过地址总线发来的地址会存放在MAR里面
* 数据总线
存储单元位宽的整数倍
* MDR(Memory Data Register 存储器数据寄存器)
* 控制总线
接受来自CPU的读写传输完成等信号
* CPU
包含控制器和计算器
* 控制器
* 指令寄存器(IR Instruction Register)
正在执行或者即将执行的指令
* 程序计数器(PC)
吓一跳指令的存储单元位置，具有自动增量计数的功能

* RCU
* Page Fault
CPU读取page table是, 发现内存地址对应的地址在磁盘上

* PageTable
保存在内存上的各个进程的VPN(virtual page number)到PPN(physical page number)的转化

* TLB/translation lookaside buffer
因为每次读取pagetable都很慢, 所以有了tlb. 如果hit, 在1cycle内就能返回结果. 如果miss, 需要10~100cycle  
0.01%~1%的miss rate(20%~40% for sparse application)

* mmu/memory management unit
负责地址转化和raise page fault的硬件

* DMA
当Page Fault时,需要等待很久, DMA就负责后台异步把内存写入磁盘  
数据写入也是用DMA来控制的  

* [PLL/Phase Locked Loop锁相环](https://www.youtube.com/watch?v=YtlwIFsiWtE)
用来增加晶振的频率

    * 鉴相器
    输入1位晶振的电压, 输入2为后面VCO的电压. 输出为晶振电压降高,但VCO电压低时, 为高电压. 这样VCO频率就变大, 知道VCO频率和输入一致

    * 低通滤波器
    鉴相器出来电压时矩形波, 利用这个变平滑后给VCO

    * VCO/Voltage Controlled Oscillator 压控振荡器
    电压越大, 频率越大. 哪怕电压变压很小, 频率变化也很大

    * 如何翻倍呢
    在VCO和鉴相器之间添加分频器

    * 如何分频呢? 用计数器取模

* COW/copy on write
进程fork或者起来的时候, 我们把数据段设置成readonly. 当有写操作时,才会触发page fault. 然后才会写.
    * 同一个进程里能否利用这个属性, 创建userlist, 改的时候才复制user出来? 有点困难,相当于把用户信息从内存转移到TLB并且改任意一个字节都导致要COW

### [TLB](https://www.youtube.com/watch?v=A9WLYbE0p-I&t=858s)
1. TLB的硬件原理
2. 多个进程能否使用同一个TLB或者PageTable避免进程切换的开销
3. 当page table满了的时候, 能否优先删除clean的, 而不是LRU的
4. TLB应该和进程直接相关的, 和cache能否做在一起呢

* 案例
比如32比特的虚拟地址, 30比特的物理地址. pagesize是4kb, 所以12bit是offset. 20bit要映射到18bit.  
每个program需要`2**20`行, 就是1M, 每行38bit就是4M左右. 50个程序就会有200M内存用来保存page tables  

    * 多层结构
    linux现在有5层
    一个进程2**32字节内存, 需要2**20行TLB, 我们拆分成2**10个chunk, 每个chunk 2**10. chunk也改成tlb
    这样只有level1的page table需要保存在内存里

* 经常分配后,内存碎了怎么办

## 内存
* [层级 channel dimm rank chip bank row column](https://blog.csdn.net/qq_50998481/article/details/139067027)
* [内存的page hit](https://www.youtube.com/watch?v=7J7X7aZvMXQ)

* [升压原理](https://www.youtube.com/watch?v=EhKEqi74yAQ)
* [利用2个二极管,2个电容把电压加倍](https://www.youtube.com/watch?v=1XKMFFTm-UY)
只适合大阻抗的设备, 不然来不及升压,电容就用完了

* [snoopimpl](https://www.cs.cmu.edu/afs/cs/academic/class/15418-s19/www/lectures/12_snoopimpl.pdf)


## ROM
* [bios的原理](https://www.youtube.com/watch?v=h_kAcVuJEm0)
* ROM Matrix.
* multiplexer(2**n个输入, 使用n个控制来决定哪个是输出)
* demultiplexer(反过来,根据控制决定输出到哪个output line)
* Decoder:
DeMux/demultiplexer without and data input


## [内核态](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%87%8D%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C/14%20%20%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%EF%BC%9A%E7%94%A8%E6%88%B7%E6%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E7%BA%BF%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F.md)
## 计算机组成原理

### 第一讲 计算机基本结构
* [104 计算机结构的简化模型][104]
* [105 计算机执行指令的过程][105]
    1. PC(0001) - 内部总线 - MAR: 告诉存储器，我要读那个地址的指令
    2. MAR - 地址总线 - 存储器MAR; CPU控制电路(READ) - 控制总线 - 存储器控制逻辑
    3. 存储单元(0001对应的数据10101010) - 存储器MDR; 存储器控制逻辑(READY) - 控制总线 - CPU控制电路; 存储器MRD - 数据总线
    4. CPU的MRD - 内部总线 - IR; PC+=1; 至此，IR内存放了10101010,取指完毕

[104]: https://www.coursera.org/learn/jisuanji-zucheng/lecture/1wVRC/104-ji-suan-ji-jie-gou-de-jian-hua-mo-xing
[105]: https://www.coursera.org/learn/jisuanji-zucheng/lecture/8Xyeu/105-ji-suan-ji-zhi-xing-zhi-ling-de-guo-cheng


## 高性能计算机
### 术语
* 动态功率
```
P = 1/2 * C * V**2 * f * a  # 电容 * 电压的平方 * 频率 * 活跃系数
```
* [静态功率](https://www.youtube.com/watch?v=zN5lg91v40g&list=PLAwxTw4SYaPmqpjgrmf4-DGlaeV0om4iP&index=16)
根据静态功率和动态功率, 低负载情况下, 可能高压状态下反而导致功耗下降

### 流水线
当前30到40级流水线性能最好. 但是能耗比较高. 所以最后实际生产一般是10到15级
* [冲突处理](https://www.youtube.com/watch?v=x6vuFvSg2Uo&list=PLAwxTw4SYaPmqpjgrmf4-DGlaeV0om4iP&index=78)
    1. flush
    2. stall
    3. 修复之前指令的数据
        * forwarding 直接把alu的数据传给下一跳指令的alu

## CPU生产过程
* [youtube](https://www.youtube.com/watch?v=LcGGI2BIymg)
总体不错, 但是金属线怎么连的不具体
* [youtube](https://www.youtube.com/watch?v=okCUq_yWVxk)
金属连线也是一样的. 多加几层
